function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

class NextkitError extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
  }

}
/**
 * This class exists because JavaScript, annoyingly, lets you throw anything.
 *
 * By constructing a WrappedError, we can be sure that all errors that could happen
 * inside of nextkit are always an instance of Error (therefore instanceof checks will work).
 */

class WrappedError extends Error {
  constructor(data) {
    super('Some data was thrown, but it was not an instance of an Error, so a WrappedError was thrown instead. Access the .data property to read the original data that was thrown');
    this.data = data;
  }

}
function hasProp(value, prop) {
  if (value === null || value === undefined) {
    return false;
  }

  if (typeof value !== 'object') {
    return false;
  }

  return prop in value;
}
var NO_RESPONSE_SENTINEL = {};
function createAPI(config) {
  var getResult = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (handlers, _req, _res) {
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
      var req = _req;
      var res = _res;

      res.throw = function (status, message) {
        throw new NextkitError(status, message);
      };

      var handler = handlers[req.method];

      try {
        if (!handler) {
          var _req$method;

          throw new NextkitError(405, "Cannot ".concat((_req$method = req.method) !== null && _req$method !== void 0 ? _req$method : 'n/a', " this route"));
        } // Context will be null if no getContext is provided. The type is null when the option is not provided
        // into context, so it's safe to default to null here. We should cast to `never` to make sure
        // that TypeScript doesn't tell us it will be the same as Context at runtime, so never excludes
        // it from the type


        var ctx = 'getContext' in config ? yield config.getContext(req, res) : null;
        var result = yield handler({
          ctx,
          req,
          res
        });

        if (hasProp(result, '_redirect') && typeof result._redirect === 'string') {
          res.redirect(result._redirect);
          return NO_RESPONSE_SENTINEL;
        }

        return result;
      } catch (error) {
        // `NextkitError`s are intended to be handled by nextkit and returned by the API without the onError func
        if (error instanceof NextkitError) {
          res.status(error.code).json({
            status: error.code,
            message: error.message,
            data: null,
            success: false
          });
          return NO_RESPONSE_SENTINEL;
        }

        var wrapped = error instanceof Error ? error : new WrappedError(error);
        var {
          status: _status,
          message: _message
        } = yield config.onError(req, res, wrapped);
        res.status(_status).json({
          success: false,
          data: null,
          message: _message,
          status: _status
        });
        return NO_RESPONSE_SENTINEL;
      }
    });

    return function getResult(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();

  var handler = handlers => /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (req, res) {
      var result = yield getResult(handlers, req, res); // Hacky, but we have already sent a response,
      // so don't do it again!

      if (result === NO_RESPONSE_SENTINEL) {
        return;
      }

      if (res.headersSent) {
        console.warn('[nextkit] Nextkit has possibly detected a bug â€” headers have been sent but a NO_RESPONSE_SENTINEL was not found as an internal result type. Exiting early to prevent a double-send.');
        return;
      }

      res.json({
        success: true,
        data: result,
        status: 200,
        message: null
      });
    });

    return function (_x4, _x5) {
      return _ref2.apply(this, arguments);
    };
  }();

  handler.raw = handlers => {
    return /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (req, res) {
        yield getResult(handlers, req, res);
      });

      return function (_x6, _x7) {
        return _ref3.apply(this, arguments);
      };
    }();
  };

  return handler;
}

export { NextkitError, WrappedError, createAPI, createAPI as default, hasProp };
