import type { NextApiHandler, NextApiRequest, NextApiResponse } from 'next';
export interface BaseAPIResponse {
    status: number;
}
export interface ErroredAPIResponse extends BaseAPIResponse {
    success: false;
    data: null;
    message: string;
}
export declare type Method = 'POST' | 'DELETE' | 'GET' | 'PATCH' | 'PUT';
export interface SuccessAPIResponse<T> extends BaseAPIResponse {
    success: true;
    data: T;
    message: null;
}
export declare type APIResponse<T> = SuccessAPIResponse<T> | ErroredAPIResponse;
export declare type NextkitRequest = NextApiRequest;
export declare type NextkitResponse<T> = NextApiResponse<T> & {
    throw(status: number, message: string): never;
};
export declare type NextkitErrorHandler = (req: NextApiRequest, res: NextApiResponse<ErroredAPIResponse>, error: Error) => Promise<{
    status: number;
    message: string;
}>;
export interface ConfigWithoutContext {
    onError: NextkitErrorHandler;
}
export declare type Redirect = {
    _redirect: string;
};
export declare type NextkitHandler<Context, Result> = (data: {
    ctx: Context;
    req: NextkitRequest;
    res: NextkitResponse<APIResponse<Result>>;
}) => Promise<Result | Redirect>;
export declare type NextkitRawHandler<Context> = (data: {
    ctx: Context;
    req: NextkitRequest;
    res: NextkitResponse<unknown>;
}) => Promise<unknown>;
export declare type HandlerInit = Partial<Record<Method, unknown>>;
export interface ConfigWithContext<Context> extends ConfigWithoutContext {
    getContext(req: NextkitRequest, res: NextkitResponse<APIResponse<any>>): Promise<Context>;
}
export declare class NextkitError extends Error {
    readonly code: number;
    constructor(code: number, message: string);
}
/**
 * This class exists because JavaScript, annoyingly, lets you throw anything.
 *
 * By constructing a WrappedError, we can be sure that all errors that could happen
 * inside of nextkit are always an instance of Error (therefore instanceof checks will work).
 */
export declare class WrappedError<T> extends Error {
    readonly data: T;
    constructor(data: T);
}
export declare type Config<Context = null> = ConfigWithContext<Context> | ConfigWithoutContext;
export declare type HandlersMap<Context, Init> = {
    [Method in keyof Init]: NextkitHandler<Context, Init[Method] | Redirect>;
};
export declare type ExportedHandler<Handlers extends HandlerInit> = (req: NextApiRequest, res: NextApiResponse<APIResponse<Handlers[keyof Handlers]>>) => Promise<void>;
export declare type MapHandlerResults<Context, Handlers extends HandlersMap<Context, HandlerInit>> = {
    [Method in keyof Handlers]: Handlers[Method] extends NextkitHandler<Context, infer R> ? R : never;
};
export declare type Then<T> = T extends PromiseLike<infer R> ? Then<R> : T;
export declare type ThenFn<T> = T extends (...args: any) => PromiseLike<infer R> ? R : T;
export declare type InferAPIResponses<T> = T extends ExportedHandler<MapHandlerResults<any, infer Handlers>> ? {
    [Method in keyof Handlers]: Exclude<ThenFn<Handlers[Method]>, Redirect>;
} : never;
export declare type InferAPIResponse<T, M extends Method> = InferAPIResponses<T>[M];
export declare type GetAPIContext<T> = T extends (handlers: Record<Method, NextkitHandler<infer Context, unknown>>) => unknown ? Context : never;
export declare function hasProp<Prop extends string | number | symbol>(value: unknown, prop: Prop): value is Record<Prop, unknown>;
export default function createAPI<Context = null>(config: Config<Context>): {
    <Init extends Partial<Record<Method, unknown>>, Handlers extends HandlersMap<Context, Init> = HandlersMap<Context, Init>>(handlers: Handlers): ExportedHandler<MapHandlerResults<Context, Handlers>>;
    raw(handlers: {
        POST?: NextkitRawHandler<Context> | undefined;
        DELETE?: NextkitRawHandler<Context> | undefined;
        GET?: NextkitRawHandler<Context> | undefined;
        PATCH?: NextkitRawHandler<Context> | undefined;
        PUT?: NextkitRawHandler<Context> | undefined;
    }): NextApiHandler;
};
export { createAPI };
